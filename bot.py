import telebot
import re
import threading
import time
import json
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
from datetime import datetime
from p import check_card  # Make sure check_card(cc_line) is in p.py

# BOT Configuration
BOT_TOKEN = '7939333845:AAGtCSoIUFQPXH94-35h7lWcIuPD30tRyYY'
ADMIN_ID = 6994528708  # Replace with your Telegram user ID (int)
AUTHORIZED_GROUP_CHAT_LINK = "https://t.me/b3_solox_bot" # Replace with your group chat link

bot = telebot.TeleBot(BOT_TOKEN)

AUTHORIZED_USERS = {} # Stores user_id: expiry_timestamp or "forever"
AUTHORIZED_CHATS = {} # Stores chat_id: expiry_timestamp or "forever" for groups/channels

# ---------------- Helper Functions ---------------- #

def load_auth():
    try:
        with open("authorized.json", "r") as f:
            data = json.load(f)
            # Separate users and chats if they were mixed previously
            users = {k: v for k, v in data.items() if int(k) > 0}
            chats = {k: v for k, v in data.items() if int(k) < 0}
            return users, chats
    except (FileNotFoundError, json.JSONDecodeError):
        return {}, {}

def save_auth(users_data, chats_data):
    # Combine users and chats into one dictionary for storage
    combined_data = {**users_data, **chats_data}
    with open("authorized.json", "w") as f:
        json.dump(combined_data, f)

# Load data at startup
AUTHORIZED_USERS, AUTHORIZED_CHATS = load_auth()

def is_authorized(chat_id):
    # Admin is always authorized
    if chat_id == ADMIN_ID:
        return True

    # Check for individual user authorization
    if str(chat_id) in AUTHORIZED_USERS:
        expiry = AUTHORIZED_USERS[str(chat_id)]
        if expiry == "forever":
            return True
        if time.time() < expiry:
            return True
        else:
            # User authorization expired
            del AUTHORIZED_USERS[str(chat_id)]
            save_auth(AUTHORIZED_USERS, AUTHORIZED_CHATS)
            return False

    # Check for group chat authorization
    if chat_id < 0 and str(chat_id) in AUTHORIZED_CHATS: # Negative chat_id for groups/channels
        expiry = AUTHORIZED_CHATS[str(chat_id)]
        if expiry == "forever":
            return True
        if time.time() < expiry:
            return True
        else:
            # Group authorization expired
            del AUTHORIZED_CHATS[str(chat_id)]
            save_auth(AUTHORIZED_USERS, AUTHORIZED_CHATS)
            return False

    return False

def normalize_card(text):
    """
    Normalize credit card from any format to cc|mm|yy|cvv
    Improved to handle common variations more robustly.
    """
    if not text:
        return None

    # Replace common separators with a single space
    text = text.replace('\n', ' ').replace('/', ' ').replace(':', ' ').replace('-', ' ')

    # Regex to find potential card parts
    # CC: 13-16 digits
    # MM: 01-12 (2 digits)
    # YY: 2 or 4 digits (e.g., 26 or 2026)
    # CVV: 3 or 4 digits

    # Attempt to find the full pattern first
    match = re.search(r'(\d{13,16})\s*\|\s*(\d{1,2})\s*\|\s*(\d{2,4})\s*\|\s*(\d{3,4})', text)
    if match:
        cc, mm, yy, cvv = match.groups()
        # Ensure MM is two digits
        mm = mm.zfill(2)
        # Convert 2-digit year to 4-digit if necessary
        if len(yy) == 2:
            current_year_prefix = str(datetime.now().year)[:2] # e.g., "20"
            yy = current_year_prefix + yy
        return f"{cc}|{mm}|{yy}|{cvv}"

    # If direct match fails, try to extract parts individually
    numbers = re.findall(r'\d+', text)
    cc = ''
    mm = ''
    yy = ''
    cvv = ''

    for part in numbers:
        if len(part) >= 13 and len(part) <= 16 and not cc: # Credit card number
            cc = part
        elif len(part) == 2 and 1 <= int(part) <= 12 and not mm: # Month (2 digits, 1-12)
            mm = part
        elif len(part) == 4 and part.startswith('20') and not yy: # 4-digit year starting with 20
            yy = part
        elif len(part) == 2 and not part.startswith('20') and not yy: # 2-digit year
            current_year_prefix = str(datetime.now().year)[:2]
            yy = current_year_prefix + part
        elif len(part) in [3, 4] and not cvv: # CVV (3-4 digits)
            cvv = part
        # A more robust approach would be to look for month/year pairs together if possible

    # Final check for validity and re-assemble
    if cc and mm and yy and cvv:
        # Additional validation: year should be in the future or current
        try:
            exp_year = int(yy)
            exp_month = int(mm)
            current_year = datetime.now().year
            current_month = datetime.now().month

            if exp_year < current_year or (exp_year == current_year and exp_month < current_month):
                return None # Card is expired
        except ValueError:
            return None # Invalid month/year format

        return f"{cc}|{mm}|{yy}|{cvv}"

    return None

# ---------------- Bot Commands ---------------- #

@bot.message_handler(commands=['start'])
def start_handler(msg):
    bot.reply_to(msg, """‚ú¶‚îÅ‚îÅ‚îÅ[ ·¥°·¥á ü·¥Ñ·¥è·¥ç·¥á ·¥õ·¥è ·¥Ñ·¥Ñ ·¥Ñ ú·¥á·¥Ñ·¥ã·¥á Ä  ô·¥è·¥õ ]‚îÅ‚îÅ‚îÅ‚ú¶

‚ü° ·¥è…¥ ü è ·¥Ä·¥ú·¥õ ú·¥è Ä…™·¥¢·¥á·¥Ö ·¥ç·¥á·¥ç ô·¥á ÄÍú± ·¥Ñ·¥Ä…¥ ·¥úÍú±·¥á ·¥õ ú…™Íú±  ô·¥è·¥õ
‚ü° ·¥úÍú±·¥á /b3 ·¥õ·¥è ·¥Ñ ú·¥á·¥Ñ·¥ã Íú±…™…¥…¢ ü·¥á ·¥Ñ·¥Ä Ä·¥Ö
‚ü° Íú∞·¥è Ä ·¥ç·¥ÄÍú±Íú± ·¥Ñ ú·¥á·¥Ñ·¥ã,  Ä·¥á·¥ò ü è ·¥Ñ·¥Ñ Íú∞…™ ü·¥á ·¥°…™·¥õ ú /mb3

 ô·¥è·¥õ ·¥ò·¥è·¥°·¥á Ä·¥á·¥Ö  ô è @its_soloz""")

@bot.message_handler(commands=['admin'])
def admin_commands_handler(msg):
    if msg.from_user.id != ADMIN_ID:
        return
    bot.reply_to(msg, """‚ú¶‚îÅ‚îÅ‚îÅ[ ·¥Ä·¥Ö·¥ç…™…¥ ·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥ÖÍú± ]‚îÅ‚îÅ‚îÅ‚ú¶

‚ü° `/auth <user_id_or_chat_id> [days]` - Authorize a user or group (days optional, "forever" if not specified)
‚ü° `/rm <user_id_or_chat_id>` - Remove authorization for a user or group
‚ü° `/broadcast <message>` - Send a message to all authorized DMs and groups
‚ü° `/stats` - Show authorization statistics (future enhancement if needed)

Example:
`/auth 123456789 30` (Authorizes user 123456789 for 30 days)
`/auth -1001234567890 forever` (Authorizes group -1001234567890 forever)
`/broadcast Hello everyone!` (Broadcasts "Hello everyone!")
""")

@bot.message_handler(commands=['auth'])
def authorize_user_or_chat(msg):
    if msg.from_user.id != ADMIN_ID:
        return
    try:
        parts = msg.text.split()
        if len(parts) < 2:
            return bot.reply_to(msg, "‚ùå Usage: /auth <user_id_or_chat_id> [days]")

        target_id_str = parts[1]
        
        # Determine if it's a user or chat ID
        if target_id_str.startswith('@'):
            return bot.reply_to(msg, "‚ùå Use numeric Telegram ID, not @username.")
        
        target_id = int(target_id_str)

        days = int(parts[2]) if len(parts) > 2 else None
        expiry = "forever" if not days else time.time() + (days * 86400)

        if target_id > 0: # It's a user ID
            AUTHORIZED_USERS[str(target_id)] = expiry
            save_auth(AUTHORIZED_USERS, AUTHORIZED_CHATS)
            msg_text = f"‚úÖ Authorized user {target_id} for {days} days." if days else f"‚úÖ Authorized user {target_id} forever."
        else: # It's a group/channel ID (negative)
            AUTHORIZED_CHATS[str(target_id)] = expiry
            save_auth(AUTHORIZED_USERS, AUTHORIZED_CHATS)
            msg_text = f"‚úÖ Authorized group/channel {target_id} for {days} days." if days else f"‚úÖ Authorized group/channel {target_id} forever."
        
        bot.reply_to(msg, msg_text)
    except ValueError:
        bot.reply_to(msg, "‚ùå Invalid ID or days format. Please use numeric ID and integer for days.")
    except Exception as e:
        bot.reply_to(msg, f"‚ùå Error: {e}")

@bot.message_handler(commands=['rm'])
def remove_auth(msg):
    if msg.from_user.id != ADMIN_ID:
        return
    try:
        parts = msg.text.split()
        if len(parts) < 2:
            return bot.reply_to(msg, "‚ùå Usage: /rm <user_id_or_chat_id>")
        
        target_id_str = parts[1]
        target_id = int(target_id_str)

        if target_id > 0: # It's a user ID
            if str(target_id) in AUTHORIZED_USERS:
                del AUTHORIZED_USERS[str(target_id)]
                save_auth(AUTHORIZED_USERS, AUTHORIZED_CHATS)
                bot.reply_to(msg, f"‚úÖ Removed user {target_id} from authorized users.")
            else:
                bot.reply_to(msg, "‚ùå User is not authorized.")
        else: # It's a group/channel ID
            if str(target_id) in AUTHORIZED_CHATS:
                del AUTHORIZED_CHATS[str(target_id)]
                save_auth(AUTHORIZED_USERS, AUTHORIZED_CHATS)
                bot.reply_to(msg, f"‚úÖ Removed group/channel {target_id} from authorized chats.")
            else:
                bot.reply_to(msg, "‚ùå Group/channel is not authorized.")
    except ValueError:
        bot.reply_to(msg, "‚ùå Invalid ID format. Please use a numeric ID.")
    except Exception as e:
        bot.reply_to(msg, f"‚ùå Error: {e}")

@bot.message_handler(commands=['broadcast'])
def broadcast_message(msg):
    if msg.from_user.id != ADMIN_ID:
        return
    try:
        message_to_send = msg.text.split(None, 1)
        if len(message_to_send) < 2:
            return bot.reply_to(msg, "‚ùå Usage: /broadcast <your message>")
        
        message_to_send = message_to_send[1]

        # Broadcast to authorized users (DMs)
        for user_id_str in list(AUTHORIZED_USERS.keys()):
            user_id = int(user_id_str)
            if is_authorized(user_id): # Check if still authorized before sending
                try:
                    bot.send_message(user_id, f"üì¢ Broadcast Message:\n\n{message_to_send}")
                    time.sleep(0.1) # Small delay to avoid hitting Telegram API limits
                except Exception as e:
                    print(f"Failed to send broadcast to user {user_id}: {e}")
                    # Optionally, remove users who have blocked the bot
                    # if "bot was blocked by the user" in str(e).lower():
                    #     del AUTHORIZED_USERS[user_id_str]
                    #     save_auth(AUTHORIZED_USERS, AUTHORIZED_CHATS)

        # Broadcast to authorized group chats
        for chat_id_str in list(AUTHORIZED_CHATS.keys()):
            chat_id = int(chat_id_str)
            if is_authorized(chat_id): # Check if still authorized before sending
                try:
                    bot.send_message(chat_id, f"üì¢ Broadcast Message:\n\n{message_to_send}")
                    time.sleep(0.1) # Small delay
                except Exception as e:
                    print(f"Failed to send broadcast to chat {chat_id}: {e}")

        bot.reply_to(msg, "‚úÖ Broadcast message sent to all authorized users and groups.")

    except Exception as e:
        bot.reply_to(msg, f"‚ùå Error during broadcast: {e}")

# This handler should be placed BEFORE other command handlers that require authorization,
# to catch unauthorized users trying to use any command in a private chat.
@bot.message_handler(func=lambda message: message.chat.type == 'private' and not is_authorized(message.from_user.id))
def unauthorized_private_chat_handler(msg):
    bot.reply_to(msg, f"""‚ú¶‚îÅ‚îÅ‚îÅ[ ¬†·¥Ä·¥Ñ·¥Ñ·¥áÍú±Íú± ·¥Ö·¥á…¥…™·¥á·¥Ö ]‚îÅ‚îÅ‚îÅ‚ú¶

‚ü°  è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥Ä·¥ú·¥õ ú·¥è Ä…™·¥¢·¥á·¥Ö ·¥õ·¥è ·¥úÍú±·¥á ·¥õ ú…™Íú±  ô·¥è·¥õ …™…¥ ·¥ò Ä…™·¥†·¥Ä·¥õ·¥á ·¥Ñ ú·¥Ä·¥õ.
‚ü° ·¥ò ü·¥á·¥ÄÍú±·¥á ·¥úÍú±·¥á ·¥õ ú…™Íú±  ô·¥è·¥õ …™…¥ ·¥õ ú·¥á ·¥èÍú∞Íú∞…™·¥Ñ…™·¥Ä ü …¢ Ä·¥è·¥ú·¥ò ·¥Ñ ú·¥Ä·¥õ Íú∞·¥è Ä Íú∞ Ä·¥á·¥á ·¥úÍú±·¥Ä…¢·¥á: {AUTHORIZED_GROUP_CHAT_LINK}

‚úß ·¥Ñ·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ ·¥Ä·¥Ö·¥ç…™…¥ Íú∞·¥è Ä ·¥Ä·¥ú·¥õ ú·¥è Ä…™·¥¢·¥Ä·¥õ…™·¥è…¥: @its_soloz""")


@bot.message_handler(commands=['b3'])
def b3_handler(msg):
    # For group chats, authorization is based on the chat_id, not individual user_id
    current_chat_id = msg.chat.id
    if not is_authorized(current_chat_id):
        return bot.reply_to(msg, """‚ú¶‚îÅ‚îÅ‚îÅ[ ¬†·¥Ä·¥Ñ·¥Ñ·¥áÍú±Íú± ·¥Ö·¥á…¥…™·¥á·¥Ö ]‚îÅ‚îÅ‚îÅ‚ú¶

‚ü°  è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥Ä·¥ú·¥õ ú·¥è Ä…™·¥¢·¥á·¥Ö ·¥õ·¥è ·¥úÍú±·¥á ·¥õ ú…™Íú±  ô·¥è·¥õ
‚ü° ·¥è…¥ ü è ·¥Ä·¥ú·¥õ ú·¥è Ä…™·¥¢·¥á·¥Ö ·¥ç·¥á·¥ç ô·¥á ÄÍú±/…¢ Ä·¥è·¥ú·¥òÍú± ·¥úÍú±·¥á ·¥õ ú…™Íú±  ô·¥è·¥õ

‚úß ·¥ò ü·¥á·¥ÄÍú±·¥á ·¥Ñ·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ ·¥Ä·¥Ö·¥ç…™…¥ Íú∞·¥è Ä ·¥Ä·¥ú·¥õ ú·¥è Ä…™·¥¢·¥Ä·¥õ…™·¥è…¥: @its_soloz""")

    cc = None

    # Check if user replied to a message
    if msg.reply_to_message:
        # Extract CC from replied message
        replied_text = msg.reply_to_message.text or ""
        cc = normalize_card(replied_text)

        if not cc:
            return bot.reply_to(msg, "‚ú¶‚îÅ‚îÅ‚îÅ[ …™…¥·¥†·¥Ä ü…™·¥Ö Íú∞·¥è Ä·¥ç·¥Ä·¥õ ]‚îÅ‚îÅ‚îÅ‚ú¶\n\n"
"‚ü° ·¥Ñ·¥è·¥ú ü·¥Ö…¥'·¥õ ·¥áx·¥õ Ä·¥Ä·¥Ñ·¥õ ·¥†·¥Ä ü…™·¥Ö ·¥Ñ·¥Ä Ä·¥Ö …™…¥Íú∞·¥è Íú∞ Ä·¥è·¥ç  Ä·¥á·¥ò ü…™·¥á·¥Ö ·¥ç·¥áÍú±Íú±·¥Ä…¢·¥á\n\n"
"·¥Ñ·¥è Ä Ä·¥á·¥Ñ·¥õ Íú∞·¥è Ä·¥ç·¥Ä·¥õ\n\n"
"`/b3 4556737586899855|12|2026|123`\n\n"
"‚úß ·¥Ñ·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ ·¥Ä·¥Ö·¥ç…™…¥ …™Íú∞  è·¥è·¥ú …¥·¥á·¥á·¥Ö  ú·¥á ü·¥ò")
    else:
        # Check if CC is provided as argument
        args = msg.text.split(None, 1)
        if len(args) < 2:
            return bot.reply_to(msg, "‚ú¶‚îÅ‚îÅ‚îÅ[ …™…¥·¥†·¥Ä ü…™·¥Ö Íú∞·¥è Ä·¥ç·¥Ä·¥õ ]‚îÅ‚îÅ‚îÅ‚ú¶\n\n"
"‚ü° ·¥ò ü·¥á·¥ÄÍú±·¥á ·¥úÍú±·¥á ·¥õ ú·¥á ·¥Ñ·¥è Ä Ä·¥á·¥Ñ·¥õ Íú∞·¥è Ä·¥ç·¥Ä·¥õ ·¥õ·¥è ·¥Ñ ú·¥á·¥Ñ·¥ã ·¥Ñ·¥Ä Ä·¥ÖÍú±\n\n"
"·¥Ñ·¥è Ä Ä·¥á·¥Ñ·¥õ Íú∞·¥è Ä·¥ç·¥Ä·¥õ\n\n"
"`/b3 4556737586899855|12|2026|123`\n\n"
"·¥è Ä  Ä·¥á·¥ò ü è ·¥õ·¥è ·¥Ä ·¥ç·¥áÍú±Íú±·¥Ä…¢·¥á ·¥Ñ·¥è…¥·¥õ·¥Ä…™…¥…™…¥…¢ ·¥Ñ·¥Ñ ·¥°…™·¥õ ú `/b3`\n\n"
"‚úß ·¥Ñ·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ ·¥Ä·¥Ö·¥ç…™…¥ …™Íú∞  è·¥è·¥ú …¥·¥á·¥á·¥Ö  ú·¥á ü·¥ò")

        # Try to normalize the provided CC
        raw_input = args[1]

        # Directly normalize, the function is now more robust
        cc = normalize_card(raw_input)

        if not cc:
            return bot.reply_to(msg, "‚ú¶‚îÅ‚îÅ‚îÅ[ …™…¥·¥†·¥Ä ü…™·¥Ö Íú∞·¥è Ä·¥ç·¥Ä·¥õ ]‚îÅ‚îÅ‚îÅ‚ú¶\n\n"
"‚ü° ·¥ò ü·¥á·¥ÄÍú±·¥á ·¥úÍú±·¥á ·¥õ ú·¥á ·¥Ñ·¥è Ä Ä·¥á·¥Ñ·¥õ Íú∞·¥è Ä·¥ç·¥Ä·¥õ ·¥õ·¥è ·¥Ñ ú·¥á·¥Ñ·¥ã ·¥Ñ·¥Ä Ä·¥ÖÍú±\n\n"
"·¥Ñ·¥è Ä Ä·¥á·¥Ñ·¥õ Íú∞·¥è Ä·¥ç·¥Ä·¥õ\n\n"
"`/b3 4556737586899855|12|2026|123`\n\n"
"·¥è Ä  Ä·¥á·¥ò ü è ·¥õ·¥è ·¥Ä ·¥ç·¥áÍú±Íú±·¥Ä…¢·¥á ·¥Ñ·¥è…¥·¥õ·¥Ä…™…¥…™…¥…¢ ·¥Ñ·¥Ñ ·¥°…™·¥õ ú `/b3`\n\n"
"‚úß ·¥Ñ·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ ·¥Ä·¥Ö·¥ç…™…¥ …™Íú∞  è·¥è·¥ú …¥·¥á·¥á·¥Ö  ú·¥á ü·¥ò")


    processing = bot.reply_to(msg, "‚ú¶‚îÅ‚îÅ‚îÅ[ ¬†·¥ò Ä·¥è·¥Ñ·¥áÍú±Íú±…™…¥…¢ ]‚îÅ‚îÅ‚îÅ‚ú¶\n\n"
"‚ü°  è·¥è·¥ú Ä ·¥Ñ·¥Ä Ä·¥Ö …™Íú±  ô·¥á…™…¥…¢ ·¥Ñ ú·¥á·¥Ñ·¥ã...\n"
"‚ü° ·¥ò ü·¥á·¥ÄÍú±·¥á ·¥°·¥Ä…™·¥õ ·¥Ä Íú∞·¥á·¥° Íú±·¥á·¥Ñ·¥è…¥·¥ÖÍú±\n\n"
"‚úß ·¥Ö·¥è …¥·¥è·¥õ Íú±·¥ò·¥Ä·¥ç ·¥è Ä  Ä·¥áÍú±·¥ú ô·¥ç…™·¥õ ‚úß")

    def check_and_reply():
        try:
            result = check_card(cc)  # This function must be in your p.py
            bot.edit_message_text(result, msg.chat.id, processing.message_id, parse_mode='HTML')
        except Exception as e:
            bot.edit_message_text(f"‚ùå Error: {str(e)}", msg.chat.id, processing.message_id)

    threading.Thread(target=check_and_reply).start()

@bot.message_handler(commands=['mb3'])
def mb3_handler(msg):
    current_chat_id = msg.chat.id
    if not is_authorized(current_chat_id):
        return bot.reply_to(msg, """‚ú¶‚îÅ‚îÅ‚îÅ[ ¬†·¥Ä·¥Ñ·¥Ñ·¥áÍú±Íú± ·¥Ö·¥á…¥…™·¥á·¥Ö ]‚îÅ‚îÅ‚îÅ‚ú¶

‚ü°  è·¥è·¥ú ·¥Ä Ä·¥á …¥·¥è·¥õ ·¥Ä·¥ú·¥õ ú·¥è Ä…™·¥¢·¥á·¥Ö ·¥õ·¥è ·¥úÍú±·¥á ·¥õ ú…™Íú±  ô·¥è·¥õ
‚ü° ·¥è…¥ ü è ·¥Ä·¥ú·¥õ ú·¥è Ä…™·¥¢·¥á·¥Ö ·¥ç·¥á·¥ç ô·¥á ÄÍú±/…¢ Ä·¥è·¥ú·¥òÍú± ·¥úÍú±·¥á ·¥õ ú…™Íú±  ô·¥è·¥õ

‚úß ·¥ò ü·¥á·¥ÄÍú±·¥á ·¥Ñ·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ ·¥Ä·¥Ö·¥ç…™…¥ Íú∞·¥è Ä ·¥Ä·¥ú·¥õ ú·¥è Ä…™·¥¢·¥Ä·¥õ…™·¥è…¥: @its_soloz""")

    if not msg.reply_to_message:
        return bot.reply_to(msg, "‚ú¶‚îÅ‚îÅ‚îÅ[ ·¥° Ä·¥è…¥…¢ ·¥úÍú±·¥Ä…¢·¥á ]‚îÅ‚îÅ‚îÅ‚ú¶\n\n"
"‚ü° ·¥ò ü·¥á·¥ÄÍú±·¥á  Ä·¥á·¥ò ü è ·¥õ·¥è ·¥Ä `.txt` Íú∞…™ ü·¥á ·¥è Ä ·¥Ñ Ä·¥á·¥Ö…™·¥õ ·¥Ñ·¥Ä Ä·¥Ö ·¥õ·¥áx·¥õ\n\n"
"‚úß ·¥è…¥ ü è ·¥†·¥Ä ü…™·¥Ö ·¥Ñ·¥Ä Ä·¥ÖÍú± ·¥°…™ ü ü  ô·¥á ·¥Ñ ú·¥á·¥Ñ·¥ã·¥á·¥Ö & ·¥Ä·¥ò·¥ò Ä·¥è·¥†·¥á·¥Ö ·¥Ñ·¥Ä Ä·¥ÖÍú± Íú± ú·¥è·¥°…¥ ‚úß")

    reply = msg.reply_to_message

    # Detect whether it's file or raw text
    text = ""
    if reply.document:
        if reply.document.file_size > 1 * 1024 * 1024: # Limit to 1MB to prevent large file processing
            return bot.reply_to(msg, "‚ùå File too large. Maximum 1MB allowed for CC lists.")
        file_info = bot.get_file(reply.document.file_id)
        downloaded_file = bot.download_file(file_info.file_path)
        text = downloaded_file.decode('utf-8', errors='ignore')
    elif reply.text:
        text = reply.text
    
    if not text.strip():
        return bot.reply_to(msg, "‚ùå Empty text message or file.")

    # Extract CCs using improved normalization
    cc_lines = []
    for line in text.splitlines():
        line = line.strip()
        if not line:
            continue
        
        normalized_cc = normalize_card(line)
        if normalized_cc:
            cc_lines.append(normalized_cc)

    if not cc_lines:
        return bot.reply_to(msg, "‚ú¶‚îÅ‚îÅ‚îÅ[ ‚ö†Ô∏è …¥·¥è ·¥†·¥Ä ü…™·¥Ö ·¥Ñ·¥Ä Ä·¥ÖÍú± Íú∞·¥è·¥ú…¥·¥Ö ]‚îÅ‚îÅ‚îÅ‚ú¶\n\n"
"‚ü° …¥·¥è ·¥†·¥Ä ü…™·¥Ö ·¥Ñ Ä·¥á·¥Ö…™·¥õ ·¥Ñ·¥Ä Ä·¥ÖÍú± ·¥Ö·¥á·¥õ·¥á·¥Ñ·¥õ·¥á·¥Ö …™…¥ ·¥õ ú·¥á Íú∞…™ ü·¥á\n"
"‚ü° ·¥ò ü·¥á·¥ÄÍú±·¥á ·¥ç·¥Ä·¥ã·¥á Íú±·¥ú Ä·¥á ·¥õ ú·¥á ·¥Ñ·¥Ä Ä·¥ÖÍú± ·¥Ä Ä·¥á …™…¥ ·¥Ñ·¥è Ä Ä·¥á·¥Ñ·¥õ Íú∞·¥è Ä·¥ç·¥Ä·¥õ\n\n"
"·¥Ñ·¥è Ä Ä·¥á·¥Ñ·¥õ Íú∞·¥è Ä·¥ç·¥Ä·¥õ\n"
"`4556737586899855|12|2026|123`\n\n"
"‚úß ·¥Ñ·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ ·¥Ä·¥Ö·¥ç…™…¥ …™Íú∞  è·¥è·¥ú …¥·¥á·¥á·¥Ö  ú·¥á ü·¥ò")

    if not reply.document and len(cc_lines) > 15:
        return bot.reply_to(msg, "‚ú¶‚îÅ‚îÅ‚îÅ[ ‚ö†Ô∏è  ü…™·¥ç…™·¥õ ·¥áx·¥Ñ·¥á·¥á·¥Ö·¥á·¥Ö ]‚îÅ‚îÅ‚îÅ‚ú¶\n\n"
"‚ü° ·¥è…¥ ü è 15 ·¥Ñ·¥Ä Ä·¥ÖÍú± ·¥Ä ü ü·¥è·¥°·¥á·¥Ö …™…¥  Ä·¥Ä·¥° ·¥ò·¥ÄÍú±·¥õ·¥á\n"
"‚ü° Íú∞·¥è Ä ·¥ç·¥è Ä·¥á ·¥Ñ·¥Ä Ä·¥ÖÍú±, ·¥ò ü·¥á·¥ÄÍú±·¥á ·¥ú·¥ò ü·¥è·¥Ä·¥Ö ·¥Ä `.txt` Íú∞…™ ü·¥á")

    total = len(cc_lines)
    user_id = msg.from_user.id # This is the user who initiated the command
    chat_id = msg.chat.id # This is the chat where the command was initiated

    # Initial Message with Inline Buttons
    kb = InlineKeyboardMarkup(row_width=1)
    buttons = [
        InlineKeyboardButton(f"·¥Ä·¥ò·¥ò Ä·¥è·¥†·¥á·¥Ö 0 ‚úÖ", callback_data="none"),
        InlineKeyboardButton(f"·¥Ö·¥á·¥Ñ ü…™…¥·¥á·¥Ö 0 ‚ùå", callback_data="none"),
        InlineKeyboardButton(f"·¥õ·¥è·¥õ·¥Ä ü ·¥Ñ ú·¥á·¥Ñ·¥ã·¥á·¥Ö 0", callback_data="none"),
        InlineKeyboardButton(f"·¥õ·¥è·¥õ·¥Ä ü {total} ‚úÖ", callback_data="none"),
    ]
    for btn in buttons:
        kb.add(btn)

    status_msg = bot.send_message(chat_id, f"‚ú¶‚îÅ‚îÅ‚îÅ[ ¬†·¥ç·¥ÄÍú±Íú± ·¥Ñ ú·¥á·¥Ñ·¥ã Íú±·¥õ·¥Ä Ä·¥õ·¥á·¥Ö ]‚îÅ‚îÅ‚îÅ‚ú¶\n\n"
"‚ü° ·¥ò Ä·¥è·¥Ñ·¥áÍú±Íú±…™…¥…¢  è·¥è·¥ú Ä ·¥Ñ·¥Ä Ä·¥ÖÍú±...\n"
"‚ü° ·¥ò ü·¥á·¥ÄÍú±·¥á ·¥°·¥Ä…™·¥õ ·¥Ä Íú∞·¥á·¥° ·¥ç·¥è·¥ç·¥á…¥·¥õÍú±\n\n"
"  ü…™·¥†·¥á Íú±·¥õ·¥Ä·¥õ·¥úÍú± ·¥°…™ ü ü  ô·¥á ·¥ú·¥ò·¥Ö·¥Ä·¥õ·¥á·¥Ö  ô·¥á ü·¥è·¥°", reply_markup=kb)

    approved, declined, checked = 0, 0, 0

    def process_all():
        nonlocal approved, declined, checked
        for cc in cc_lines:
            try:
                checked += 1
                result = check_card(cc.strip())
                if "[APPROVED]" in result:
                    approved += 1
                    # Send approved card to the chat where the command was initiated
                    bot.send_message(chat_id, result, parse_mode='HTML')
                    # Send approved card to ADMIN_ID if not the same chat
                    if ADMIN_ID != user_id and ADMIN_ID != chat_id: # Avoid double send if admin is in the group
                        try:
                            bot.send_message(ADMIN_ID, f"‚úÖ Approved by {msg.from_user.first_name} ({user_id}) in chat {chat_id}:\n{result}", parse_mode='HTML')
                        except Exception as admin_send_e:
                            print(f"Failed to send approved card to admin: {admin_send_e}")
                else:
                    declined += 1

                # Update inline buttons
                new_kb = InlineKeyboardMarkup(row_width=1)
                new_kb.add(
                    InlineKeyboardButton(f"·¥Ä·¥ò·¥ò Ä·¥è·¥†·¥á·¥Ö {approved} üî•", callback_data="none"),
                    InlineKeyboardButton(f"·¥Ö·¥á·¥Ñ ü…™…¥·¥á·¥Ö {declined} ‚ùå", callback_data="none"),
                    InlineKeyboardButton(f"·¥õ·¥è·¥õ·¥Ä ü ·¥Ñ ú·¥á·¥Ñ·¥ã·¥á·¥Ö {checked} ‚úîÔ∏è", callback_data="none"),
                    InlineKeyboardButton(f"·¥õ·¥è·¥õ·¥Ä ü {total} ‚úÖ", callback_data="none"),
                )
                try:
                    bot.edit_message_reply_markup(chat_id, status_msg.message_id, reply_markup=new_kb)
                except telebot.apihelper.ApiTelegramException as e:
                    if "message is not modified" in str(e):
                        pass # Ignore if no change in markup
                    else:
                        print(f"Error updating message markup: {e}")
                time.sleep(1) # Reduced sleep to 1 second for faster updates

            except Exception as e:
                bot.send_message(chat_id, f"‚ùå Error processing card '{cc}': {e}")
                # You might want to log this error more specifically

        bot.send_message(chat_id, "‚ú¶‚îÅ‚îÅ‚îÅ[ ·¥Ñ ú·¥á·¥Ñ·¥ã…™…¥…¢ ·¥Ñ·¥è·¥ç·¥ò ü·¥á·¥õ·¥á·¥Ö ]‚îÅ‚îÅ‚îÅ‚ú¶\n\n"
"‚ü° ·¥Ä ü ü ·¥Ñ·¥Ä Ä·¥ÖÍú±  ú·¥Ä·¥†·¥á  ô·¥á·¥á…¥ ·¥ò Ä·¥è·¥Ñ·¥áÍú±Íú±·¥á·¥Ö\n"
"‚ü° ·¥õ ú·¥Ä…¥·¥ã  è·¥è·¥ú Íú∞·¥è Ä ·¥úÍú±…™…¥…¢ ·¥ç·¥ÄÍú±Íú± ·¥Ñ ú·¥á·¥Ñ·¥ã\n\n"
" ·¥è…¥ ü è ·¥Ä·¥ò·¥ò Ä·¥è·¥†·¥á·¥Ö ·¥Ñ·¥Ä Ä·¥ÖÍú± ·¥°·¥á Ä·¥á Íú± ú·¥è·¥°…¥ ·¥õ·¥è  è·¥è·¥ú\n"
"  è·¥è·¥ú ·¥Ñ·¥Ä…¥  Ä·¥ú…¥ /mb3 ·¥Ä…¢·¥Ä…™…¥ ·¥°…™·¥õ ú ·¥Ä …¥·¥á·¥°  ü…™Íú±·¥õ")
    threading.Thread(target=process_all).start()

# ---------------- Start Bot ---------------- #
bot.infinity_polling()